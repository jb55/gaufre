<!DOCTYPE html>
<html>
<head>
  <title>Gaufre - Commons Host</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/png" href="/favicon.png">
  <link rel="apple-touch-icon" href="/favicon.png">
  <meta name="apple-mobile-web-app-title" content="Gopher">
  <!-- <meta name="apple-mobile-web-app-capable" content="yes"> -->
  <!-- <meta name="apple-mobile-web-app-status-bar-style" content="black"> -->
  <meta name="referrer" content="no-referrer">
</head>
<body>
<style>
@font-face {
  font-family: font-stack-emoji;
  unicode-range: U+1F300-1F5FF, U+1F600-1F64F, U+1F680-1F6FF, U+2600-26FF;
  src: local(Segoe UI Emoji); /* Windows 8.1+ Edge fix */
  src:
    /* macOS, iOS */
    local(Apple Color Emoji),
    /* Windows 8.1+ */
    local(Segoe UI Emoji),
    /* Linux Firefox */
    local(Twemoji Mozilla),
    local(EmojiOne Mozilla),
    /* Ubuntu Firefox */
    local(Twitter Color Emoji),
    /* Android */
    local(Noto Color Emoji),
    local(Android Emoji),
    /* Linux */
    local(Emoji One Color),
    local(EmojiOne Color),
    local(EmojiSymbols),
    local(Symbola);
}

@font-face {
  font-family: font-stack-monospace;
  src:
    local(Menlo),
    local(Monaco),
    local(Consolas),
    local(DejaVu Sans Mono),
    local(Bitstream Vera Sans Mono),
    local(Andalé Mono);
}

:host,
:root {
  --font-stack-monospace:
    /* The emoji stack has issues with Safari. On macOS some line endings */
    /* are miscalculated, making links partially unclickable. */
    /* font-stack-emoji, */
    font-stack-monospace,
    monospace;
}

:host,
:root {
  --filter-invert: 0;
  --color-foreground: black;
  --color-background: white;
  --color-error: red;
  --color-anchor: blue;
  --color-anchor-active: red;
  --color-anchor-visited: purple;
}
@media (prefers-color-scheme: dark) {
  :host,
  :root {
    --filter-invert: 1;
    --color-foreground: white;
    --color-background: black;
    --color-error: #00ffff;
    --color-anchor: #ffff00;
    --color-anchor-active: #ff0000;
    --color-anchor-visited: #7fff7f;
  }
}

:root, html, body {
  margin: 0;
  height: 100%;
  width: 100%;
  -webkit-text-size-adjust: 100%;
  background: var(--color-background);
}
main {
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
}
main > #location {
  height: 50px;
  flex: none;
  display: flex;
  flex-direction: row;
  background-color: var(--color-foreground);
  justify-content: stretch;
  align-items: stretch;
}
main > #location > #url {
  appearance: none;
  -webkit-appearance: none;
  align-self: stretch;
  justify-self: stretch;
  text-align: center;
  margin: 0;
  padding: 0 5px;
  border: 5px solid var(--color-foreground);
  background-color: var(--color-background);
  color: var(--color-foreground);
  font-size: 16px;
  font-family: var(--font-stack-monospace);
  width: 100%;
  height: 100%;
}
main > #location > #progress {
  background: none;
  border: none;
  font-size: 0;
  width: 50px;
  height: 100%;
  overflow: hidden;
  font-family: var(--font-stack-monospace);
  text-align: center;
  flex: none;
}
main > #location > #progress:before {
  content: '🐑';
  font-size: 40px;
  filter: invert(var(--filter-invert));
}
main > #location > #progress.active {
  animation-name: spinner;
  animation-timing-function: linear;
  animation-duration: 1s;
  animation-play-state: running;
  animation-iteration-count: infinite;
}
@keyframes spinner {
  from {
    transform: rotateY(0deg);
  }
  to {
    transform: rotateY(360deg);
  }
}
main > article {
  background: var(--color-background);
  color: var(--color-foreground);
  flex: auto;
  overflow: hidden;
  display: flex;
  font-size: 0;
}
gaufre-viewport {
  display: block;
  text-align: center;
  flex: auto;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
gaufre-viewport > * {
  padding: 1.25em 0.5em;
  display: inline-block;
  text-align: left;
  font-size: 16px;
  line-height: 1.25em;
}
@media (max-width: 700px) {
  gaufre-viewport > * {
    font-size: 14px;
  }
  gaufre-viewport input[type='search'] {
    max-width: calc(100vw - 30px) !important;
  }
}
@media (max-width: 600px) {
  gaufre-viewport > * {
    font-size: 12px;
  }
  gaufre-viewport input[type='search'] {
    max-width: calc(100vw - 30px) !important;
  }
}
gaufre-directory {
}
gaufre-text {
  display: block;
  white-space: pre;
  font-family: var(--font-stack-monospace);
}
gaufre-error {
  color: red;
  display: block;
  white-space: pre;
  font-family: var(--font-stack-monospace);
}
gaufre-image {
  display: inline-block;
}
gaufre-image > img {
  width: auto;
}
gaufre-image[zoomed] > img {
  width: 100%;
}
gaufre-html {
  border: 0;
  overflow: hidden;
  padding: 0;
  height: 100%;
  width: 100%;
}
gaufre-html > iframe {
  height: 100%;
  width: 100%;
  border: 0;
}
gaufre-pdf {
  border: 0;
  overflow: hidden;
  padding: 0;
  height: 100%;
  width: 100%;
}
gaufre-pdf > iframe {
  height: 100%;
  width: 100%;
  border: 0;
}
gaufre-line {
  display: block;
}
gaufre-line[format='error'] {
  color: var(--color-error);
}
gaufre-line p {
  white-space: pre;
  font-family: var(--font-stack-monospace);
  margin: 0;
  min-height: 1em;
}
gaufre-line a {
  text-decoration: none;
  color: var(--color-anchor);
}
gaufre-line a:active {
  color: var(--color-anchor-active);
}
gaufre-line a:visited {
  color: var(--color-anchor-visited);
}
gaufre-line p + form > input[type='search'] {
  width: 50ch;
  max-width: 100%;
  padding: 4px;
  font-size: 16px;
  font-family: var(--font-stack-monospace);
  -webkit-appearance: none;
  background-color: var(--color-background);
  color: var(--color-foreground);
}
gaufre-unsupported {
  display: block;
  white-space: pre;
  font-family: var(--font-stack-monospace);
}
gaufre-download {
  font-family: var(--font-stack-monospace);
}
</style>
<main hidden>
  <form id="location">
    <input id="url" value="" name="url"
      type="search"
      autofocus
      mozactionhint="go" enterkeyhint="go"
      placeholder="Search or enter URL">
    <button type="submit" id="progress">Loading activity indicator</button>
  </form>
  <article>
    <gaufre-viewport></gaufre-viewport>
  </article>
</main>

<!-- <script src="https://unpkg.com/@ungap/event-target"></script> -->
<script>
/* eslint-disable */
/*! (c) Andrea Giammarchi - ISC */
var self=this||{};try{self.EventTarget=(new EventTarget).constructor}catch(e){!function(e,o){var t=e.create,r=e.defineProperty,n=i.prototype;function i(){"use strict";o.set(this,t(null))}function s(e,t,n){r(e,t,{configurable:!0,writable:!0,value:n})}function a(e){var t=e.options;t&&t.once&&e.target.removeEventListener(this.type,e.listener),"function"==typeof e.listener?e.listener.call(e.target,this):e.listener.handleEvent(this)}s(n,"addEventListener",function(e,t,n){for(var r=o.get(this),i=r[e]||(r[e]=[]),s=0,a=i.length;s<a;s++)if(i[s].listener===t)return;i.push({target:this,listener:t,options:n})}),s(n,"dispatchEvent",function(e){var t=o.get(this)[e.type];return t&&(s(e,"target",this),s(e,"currentTarget",this),t.slice(0).forEach(a,e),delete e.currentTarget,delete e.target),!0}),s(n,"removeEventListener",function(e,t){for(var n=o.get(this),r=n[e]||(n[e]=[]),i=0,s=r.length;i<s;i++)if(r[i].listener===t)return void r.splice(i,1)}),self.EventTarget=i}(Object,new WeakMap)}
/* eslint-enable */
</script>

<script>
/* eslint-env browser */

function typeToFormat (type, fallback = 'directory') {
  switch (type) {
    case '0':
      return 'text'
    case '3':
      return 'error'
    case '1':
      return 'directory'
    case '4': case '5': case '6': case '9': case 'D':
      return 'download'
    case '8': case 'T':
      return 'telnet'
    case 'g': case 'I': case 'p':
      return 'image'
    case 'h':
      return 'html'
    case 'i':
      return 'info'
    case 'x':
      return 'svg'
    case 's':
      return 'audio'
    case 'P': case 'd':
      return 'pdf'
    case ';':
      return 'video'
    case '7':
      return 'search'
    default:
      return fallback
  }
}

function parseLine (line) {
  const type = line.charAt(0)
  const [name, selector, host, port] = line.substr(1).split('\t')
  const origin = port === '70' ? host : `${host}:${port}`
  const path = (selector.length === 0 && type === '1')
    ? '' : `/${type}${selector}`
  return { type, name, selector, host, port, origin, path }
}

class GaufreViewport extends HTMLElement {
  clear () {
    while (this.children.length > 0) {
      this.removeChild(this.firstChild)
    }
  }

  async load ({ response, url, type, format }) {
    let renderer
    if (format === 'directory' || format === 'search') {
      renderer = document.createElement('gaufre-directory')
      const text = await response.text()
      for (const raw of text.split(/\r?\n/g)) {
        if (raw === '.') break
        if (raw) {
          const line = document.createElement('gaufre-line')
          line.textContent = raw
          renderer.appendChild(line)
        }
      }
    } else if (format === 'text' || format === 'info') {
      const text = await response.text()
      renderer = document.createElement('gaufre-text')
      renderer.textContent = text.replace(/^\.\./g, '.')
    } else if (format === 'html') {
      const text = await response.text()
      renderer = document.createElement('gaufre-html')
      renderer.source = text
    } else if (format === 'image') {
      const blob = await response.blob()
      renderer = document.createElement('gaufre-image')
      renderer.setAttribute('src', URL.createObjectURL(blob))
    } else if (format === 'svg') {
      const text = await response.text()
      renderer = document.createElement('gaufre-image')
      renderer.setAttribute('src', 'data:image/svg+xml;base64,' + btoa(text))
    } else if (format === 'audio') {
      const mime = 'audio/wav'
      const blob = new Blob([await response.blob()], { type: mime })
      renderer = document.createElement('gaufre-audio')
      renderer.srcObject = blob
    } else if (format === 'video') {
      const mime = 'video/mp4'
      const blob = new Blob([await response.blob()], { type: mime })
      renderer = document.createElement('gaufre-video')
      renderer.srcObject = blob
    } else if (format === 'pdf') {
      const mime = 'application/pdf'
      const blob = new Blob([await response.blob()], { type: mime })
      renderer = document.createElement('gaufre-pdf')
      renderer.src = URL.createObjectURL(blob)
    } else if (format === 'download') {
      renderer = document.createElement('gaufre-download')
      renderer.textContent = url
    } else if (format === 'error') {
      const text = await response.text()
      renderer = document.createElement('gaufre-line')
      renderer.textContent = text
    } else {
      renderer = document.createElement('gaufre-unsupported')
      renderer.textContent = 'Format not supported'
    }
    this.clear()
    this.appendChild(renderer)
  }

  error (error) {
    this.clear()
    console.log(error)
    const renderer = document.createElement('gaufre-error')
    renderer.textContent = error.message
    this.appendChild(renderer)
  }
}

customElements.define('gaufre-viewport', GaufreViewport)

class GaufreLine extends HTMLElement {
  set textContent (line) {
    let type, name, selector, origin, path
    try {
      ({ type, name, selector, origin, path } = parseLine(line))
    } catch (error) {
      console.error(error.message)
    }
    this._textContent = line
    const format = typeToFormat(type, 'unknown')
    if (format === 'unknown') {
      console.warn('Unknown format', line)
    }
    this.setAttribute('format', format)
    const linkableFormats = [
      'text',
      'directory',
      'download',
      'image',
      'html',
      'svg',
      'telnet',
      'audio',
      'pdf',
      'video'
    ]
    if (linkableFormats.includes(format)) {
      const paragraph = document.createElement('p')
      const anchor = document.createElement('a')
      anchor.textContent = name
      const urlPrefix = /^\/?URL:/i
      if (format === 'html' && urlPrefix.test(selector)) {
        anchor.href = selector.replace(urlPrefix, '')
      } else if (format === 'telnet') {
        anchor.href = `telnet://${origin}`
      } else {
        anchor.href = `gopher://${origin}${path}`
      }
      if (format === 'download') {
        const filename = path.replace(/^...*?([^/]+)$/, '$1') || name
        anchor.setAttribute('download', filename)
        anchor.addEventListener('click', () => {
          event.stopPropagation()
          event.preventDefault()
          const detail = { href: anchor.href, filename }
          document.dispatchEvent(new CustomEvent('download', { detail }))
        })
      }
      paragraph.appendChild(anchor)
      this.appendChild(paragraph)
    } else if (format === 'search') {
      const paragraph = document.createElement('p')
      paragraph.textContent = name
      this.appendChild(paragraph)
      const form = document.createElement('form')
      form.addEventListener('submit', () => {
        event.stopPropagation()
        event.preventDefault()
        const url = `gopher://${origin}${path}%09${encodeURI(input.value)}`
        const href = window.location.origin + `/${url}`
        window.history.pushState(null, '', href)
        window.dispatchEvent(new PopStateEvent('popstate'))
      })
      const input = document.createElement('input')
      input.setAttribute('type', 'search')
      input.setAttribute('placeholder', name)
      form.appendChild(input)
      this.appendChild(form)
    } else {
      const paragraph = document.createElement('p')
      paragraph.textContent = name === undefined ? line : name
      this.appendChild(paragraph)
    }
  }

  get textContent () {
    return this._textContent
  }
}

customElements.define('gaufre-line', GaufreLine)

class GaufreImage extends HTMLElement {
  connectedCallback () {
    if (!this.embed) {
      this.embed = document.createElement('img')
      this.embed.src = this.getAttribute('src')
      this.appendChild(this.embed)
      this.addEventListener('click', () => {
        this.toggleAttribute('zoomed')
      })
    }
  }

  static get observedAttributes () {
    return ['src']
  }

  attributeChangedCallback (name, oldValue, newValue) {
    if (this.embed) {
      this.embed[name] = newValue
    }
  }
}

customElements.define('gaufre-image', GaufreImage)

class GaufreAudio extends HTMLElement {
  connectedCallback () {
    if (!this.embed) {
      this.embed = document.createElement('audio')
      this.embed.setAttribute('controls', true)
      this.embed.setAttribute('volume', true)
      // this.embed.srcObject = this.srcObject
      const url = URL.createObjectURL(this.srcObject)
      this.embed.src = url
      this.appendChild(this.embed)
    }
  }
}

customElements.define('gaufre-audio', GaufreAudio)

class GaufreVideo extends HTMLElement {
  connectedCallback () {
    if (!this.embed) {
      this.embed = document.createElement('video')
      this.embed.setAttribute('controls', true)
      this.embed.setAttribute('volume', true)
      // this.embed.srcObject = this.srcObject
      const url = URL.createObjectURL(this.srcObject)
      this.embed.src = url
      this.appendChild(this.embed)
    }
  }
}

customElements.define('gaufre-video', GaufreVideo)

class GaufreHTML extends HTMLElement {
  connectedCallback () {
    if (!this.iframe) {
      this.iframe = document.createElement('iframe')
      this.iframe.setAttribute('sandbox', '')
      const csp = [
        'default-src \'none\'',
        'style-src \'unsafe-inline\''
      ].join('; ')
      this.iframe.setAttribute('csp', csp)
      this.iframe.srcdoc = this.source
      this.appendChild(this.iframe)
    }
  }
}

customElements.define('gaufre-html', GaufreHTML)

class GaufrePDF extends HTMLElement {
  connectedCallback () {
    if (!this.iframe) {
      this.iframe = document.createElement('iframe')
      const csp = [
        'default-src \'none\'',
        'style-src \'unsafe-inline\'',
        'object-src blob:'
      ].join('; ')
      this.iframe.setAttribute('csp', csp)
      this.iframe.src = this.src
      this.appendChild(this.iframe)
    }
  }
}

customElements.define('gaufre-pdf', GaufrePDF)

class GaufreDownload extends HTMLElement {
  set textContent (url) {
    if (!this.anchor) {
      this.anchor = document.createElement('a')
      this.anchor.textContent = url
      this.anchor.href = url
      const path = new URL(url).pathname
      const filename = path.replace(/^...*?([^/]+)$/, '$1')
      this.anchor.setAttribute('download', filename)
      this.anchor.addEventListener('click', () => {
        event.stopPropagation()
        event.preventDefault()
        const detail = { href: this.anchor.href, filename }
        document.dispatchEvent(new CustomEvent('download', { detail }))
      })
      this.appendChild(this.anchor)
    }
  }
}

customElements.define('gaufre-download', GaufreDownload)

class Gaufre extends EventTarget {
  constructor (options) {
    super()
    this.options = options
    this.gopherTypeRegex = /gopher:\/\/[^/]+(?:\/(.))?/
  }

  async navigate (url) {
    const matches = this.gopherTypeRegex.exec(url)
    const type = matches[1] || '1'
    const format = typeToFormat(type)
    const endpoint = this.options.goh + encodeURIComponent(url)
    if (format === 'download') {
      const detail = { url, type, format }
      this.dispatchEvent(new CustomEvent('response', { detail }))
      return
    }
    this.dispatchEvent(
      new CustomEvent('start', { detail: { url, endpoint } })
    )
    let response
    try {
      response = await fetch(endpoint, {
        headers: { accept: 'application/gopher' }
      })
    } catch (error) {
      this.dispatchEvent(new CustomEvent('error', { detail: error }))
    }
    if (response) {
      if (response.ok === true) {
        const detail = { response, url, type, format }
        this.dispatchEvent(
          new CustomEvent('response', { detail })
        )
      } else {
        const { status } = response
        const error = new Error()
        error.message = `${status} - Error`
        error.status = status
        this.dispatchEvent(new CustomEvent('error', { detail: error }))
      }
    }
    this.dispatchEvent(
      new CustomEvent('end', { detail: { url, endpoint } })
    )
  }
}

document.addEventListener('DOMContentLoaded', async () => {
  const SEARCH = 'gopher://gopher.floodgap.com/7/v2/vs'
  const goh = 'https://goh.commons.host:7070/?url='
  const gaufre = new Gaufre({ goh })

  document.getElementById('location')
    .addEventListener('submit', (event) => {
      event.stopPropagation()
      event.preventDefault()
      let url = document.getElementById('url').value
      if (/^https?:\/\/.+/.test(url)) {
        location = url
        return
      } else if (url.length && !url.startsWith('gopher://')) {
        if (!url.includes('.') || url.includes(' ')) {
          url = `${SEARCH}%09${url}`
        } else {
          url = `gopher://${url}`
        }
      }
      const href = window.location.origin + '/' + url
      if (location.href !== href) {
        window.history.pushState(null, '', href)
      }
      window.dispatchEvent(new PopStateEvent('popstate'))
    })

  gaufre.addEventListener('start', ({ detail: { url, endpoint } }) => {
    document.getElementById('progress')
      .classList.add('active')
    document.getElementById('url').value = encodeURI(url)
  })
  gaufre.addEventListener('error', async ({ detail }) => {
    await document.querySelector('gaufre-viewport').error(detail)
    document.querySelector('main > article').scrollTop = 0
  })
  gaufre.addEventListener('response', async ({ detail }) => {
    await document.querySelector('gaufre-viewport').load(detail)
    document.querySelector('main > article').scrollTop = 0
  })
  gaufre.addEventListener('end', ({ detail: { url, endpoint } }) => {
    document.getElementById('progress')
      .classList.remove('active')
  })

  document.addEventListener('download', async ({ detail }) => {
    const url = goh + detail.href
    const response = await fetch(url, {
      headers: { accept: 'application/gopher' }
    })
    const blob = await response.blob()
    const download = document.createElement('a')
    download.href = URL.createObjectURL(blob)
    download.setAttribute('download', detail.filename)
    download.click()
    setTimeout(() => URL.revokeObjectURL(download.href), 1e6)
  })

  document.addEventListener('click', (event) => {
    const elementNode = Node.ELEMENT_NODE
    for (const target of event.composedPath()) {
      if (target.nodeType === elementNode && target.localName === 'a') {
        if (target.protocol === 'gopher:') {
          event.stopPropagation()
          event.preventDefault()
          const href = window.location.origin + '/' + target.href
          window.history.pushState(null, '', href)
          window.dispatchEvent(new PopStateEvent('popstate'))
          break
        }
      }
    }
  })

  window.addEventListener('popstate', (event) => {
    router(location)
  })

  const title = document.title
  function router (url) {
    const path = decodeURI(url.href.substr(url.origin.length + 1))
    const squashedGopherUrl = /^gopher:\/[^/]/
    let gopherUrl
    if (path === '') {
      document.title = title
      document.querySelector('gaufre-viewport').load({
        format: 'directory',
        type: '1',
        response: {
          text: () => HOME
        }
      })
      document.querySelector('main > article').scrollTop = 0
      return
    } else if (path.startsWith('gopher://')) {
      gopherUrl = path
    } else if (squashedGopherUrl.text(path)) {
      const doubleSlash = '/' + path.replace(squashedGopherUrl, 'gopher://')
      window.history.replaceState(null, '', doubleSlash)
      window.dispatchEvent(new PopStateEvent('popstate'))
    } else {
      return
    }
    if (gopherUrl) {
      document.title = `${gopherUrl.replace(/^gopher:\/\//, '')} - ${title}`
      gaufre.navigate(gopherUrl)
    }
  }

  document.querySelector('main')
    .removeAttribute('hidden')
  router(location)
})

const HOME = `
i  ___                             _  _        _   \t\t\t
i / __|___ _ __  _ __  ___ _ _ ___| || |___ __| |_ \t\t\t
i| (__/ _ \\ '  \\| '  \\/ _ \\ ' (_-<| __ / _ (_-<  _|\t\t\t
i \\___\\___/_|_|_|_|_|_\\___/_\\_|__/|_||_\\___/__/\\__|\t\t\t
i\t\t\t
i                🐑 Commons Host\t\t\t
i\t\t\t
i  The collaborative CDN for WWW, DNS, and Gopher.\t\t\t
i\t\t\t
i+ Interesting Gopher Links\t\t\t
i\t\t\t
1  Floodgap    - Community pages & info\t\tgopher.floodgap.com\t70
1  Hacker News - Tech news and discussion\t\thngopher.com\t70
1  Gopherverse - All known Gopher servers\t/world\tgopher.floodgap.com\t70
i\t\t\t
i+ About\t\t\t
i\t\t\t
iThis is a Gopher browser in your web browser.\t\t\t
i\t\t\t
iGopher is a humble protocol, unchanged since '90s.\t\t\t
iEnjoy the simplicity of text content. But it also \t\t\t
isupports images, audio, video, PDF, and even HTML.\t\t\t
i\t\t\t
iThe Commons Host edge network provides a global, \t\t\t
ilow-latency, public Gopher-over-HTTP service.\t\t\t
iGoH is a transport, not a translator. So this \t\t\t
isingle-page app speaks pure, original Gopher.\t\t\t
i\t\t\t
i+ Web Links\t\t\t
i\t\t\t
h  Homepage    - Free and open source CDN\tURL:https://commons.host\t\t
h  Contact     - @commonshost on Twitter\tURL:https://twitter.com/commonshost\t\t
h  Source code - Protocol, servers, clients\tURL:https://www.npmjs.com/package/goh\t\t
`
</script>
</body>
</html>
